// simulate the communicator daemon and a plethora of cluck clients
//
// TODO: change the designed to a similar implementation as we have in
//       cluck_daemon_test_three_computers.rprtr
//       (i.e. expected messages are in a clear order)

hostname(variable_name: hostname)

run()
listen(address: <127.0.0.1:20002>)

call(label: func_expect_register)
call(label: func_expect_commands)
call(label: func_expect_service_status)
call(label: func_send_unlock)
call(label: func_expect_fluid_settings_listen)
call(label: func_expect_cluster_status)
call(label: func_expect_no_lock)
call(label: func_expect_lock_leaders)
call(label: func_send_unlock_with_bad_pid)
call(label: func_expect_lock_started)
call(label: func_expect_lock_ready)
call(label: func_expect_lock_failed)
call(label: func_expect_locked)
call(label: func_send_unlock_with_bad_server_name)
call(label: func_send_unlock_with_bad_object_name)
call(label: func_expect_unlocking)
call(label: func_expect_unlocked)	// this one timed out


call(label: func_drain_messages)
exit(error_message: "unexpectedly reached the end...")




// function: wait for next message
//
// if the wait times out, it is an error
// the function shows the message before returning
//
label(name: func_wait_message)
clear_message()
has_message() // the previous wait() may have read several messages at once
if(true: already_got_next_message)
label(name: wait_for_a_message)
wait(timeout: 12, mode: wait)
has_message()
if(false: wait_for_a_message) // woke up without a message, wait some more
label(name: already_got_next_message)
show_message()
return()

// Function: send QUITTING and drain messages
label(name: func_drain_messages)
print(message: "--- Sending QUITTING and draining messages...")
call(label: func_send_quitting)
clear_message()
has_message()
if(true: got_unexpected_message)
print(message: "--- Wait while draining messages...")
wait(timeout: 5, mode: drain)
has_message()
if(true: got_unexpected_message)
print(message: "--- Script is done...")
exit()
label(name: got_unexpected_message)
show_message()
exit(error_message: "got message while draining final send()")









// Function: expect REGISTER
label(name: func_expect_register)
print(message: "--- expect REGISTER ---")
call(label: func_wait_message)
call(label: func_verify_register)
call(label: func_send_help)
call(label: func_send_ready)
return()

// Function: expect COMMANDS
label(name: func_expect_commands)
print(message: "--- expect COMMANDS ---")
call(label: func_wait_message)
call(label: func_verify_commands)
return()

// Function: expect SERVICE_STATUS
label(name: func_expect_service_status)
print(message: "--- expect SERVICE_STATUS ---")
call(label: func_wait_message)
call(label: func_verify_service_status)
call(label: func_send_status_of_fluid_settings)
return()

// Function: expect FLUID_SETTINGS_LISTEN
label(name: func_expect_fluid_settings_listen)
print(message: "--- expect FLUID_SETTINGS_LISTEN ---")
call(label: func_wait_message)
call(label: func_verify_fluid_settings_listen)
call(label: func_send_fluid_settings_registered)
call(label: func_send_fluid_settings_value_updated)
call(label: func_send_fluid_settings_ready)

// here pretend a client is checking on our status a little too soon
// (i.e. we'll get a "NO_LOCK" message)
//
call(label: func_send_lock_status)

return()

// Functoin: expect CLUSTER_STATUS
label(name: func_expect_cluster_status)
print(message: "--- expect CLUSTER_STATUS ---")
call(label: func_wait_message)
call(label: func_verify_cluster_status)
call(label: func_send_cluster_up)
//call(label: func_send_cluster_complete) -- this does not currently happen because the message is tested (at least when we sent a CLUSTER_STATUS message, the broadcast may still send us the message, I think)
set_variable(name: info_mode, value: "info")
call(label: func_send_info)
return()

// Function: expect NO_LOCK
label(name: func_expect_no_lock)
print(message: "--- wait for message NO_LOCK ---")
call(label: func_wait_message)
call(label: func_verify_no_lock)
return()

// Function: expect LOCK_LEADERS
label(name: func_expect_lock_leaders)
print(message: "--- wait for message LOCK_LEADERS ---")
call(label: func_wait_message)
call(label: func_verify_lock_leaders)

// try a lock that already timed out
set_variable(name: timeout, value: 1000)
set_variable(name: lock_failed, value: "timedout/lock1")
call(label: func_send_lock)

return()

// Function: expect LOCK_STARTED
label(name: func_expect_lock_started)
print(message: "--- wait for message LOCK_STARTED ---")
call(label: func_wait_message)
call(label: func_verify_lock_started)
//call(label: func_send_cluster_up)
return()

// Function: expect LOCK_READY
label(name: func_expect_lock_ready)
print(message: "--- wait for message LOCK_READY ---")
call(label: func_wait_message)
call(label: func_verify_lock_ready)
//call(label: func_send_cluster_up)
return()

// Function: expect LOCK_FAILED
label(name: func_expect_lock_failed)
print(message: "--- wait for message LOCK_FAILED ---")
call(label: func_wait_message)
call(label: func_verify_lock_failed)
now(variable_name: timeout)
set_variable(name: timeout, value: ${timeout} + 60) // now + 1 minute
call(label: func_send_lock)
return()

// Function: expect LOCKED
label(name: func_expect_locked)
print(message: "--- expect LOCKED ---")
call(label: func_wait_message)
call(label: func_verify_locked)
set_variable(name: info_mode, value: "debug")
call(label: func_send_info)
return()

// Function: expect UNLOCKED
label(name: func_expect_unlocked)
print(message: "--- expect UNLOCKED ---")
call(label: func_wait_message)
call(label: func_verify_unlocked)
return() // +draining

// Function:: expect UNLOCKING
label(name: func_expect_unlocking)
print(message: "--- expect UNLOCKING ---")
call(label: func_wait_message)
call(label: func_verify_unlocking)
return()









// Function: verify REGISTER 
label(name: func_verify_register)
verify_message(
	command: REGISTER,
	required_parameters: {
		service: cluckd,
		version: 1
	})
return()

// Function: verify a LOCKED reply
label(name: func_verify_locked)
verify_message(
	command: LOCKED,
	server: ${hostname},
	service: website,
	required_parameters: {
		object_name: "lock1",
		timeout_date: `^[0-9]+(\\.[0-9]+)?$`,
		unlocked_date: `^[0-9]+(\\.[0-9]+)?$`
	})
return()

// Function: verify a COMMANDS reply
label(name: func_verify_commands)
verify_message(
	command: COMMANDS,
	required_parameters: {
		list: "ABSOLUTELY,ACTIVATE_LOCK,ADD_TICKET,ALIVE,CLUSTER_DOWN,CLUSTER_UP,DISCONNECTED,DROP_TICKET,FLUID_SETTINGS_DEFAULT_VALUE,FLUID_SETTINGS_DELETED,FLUID_SETTINGS_OPTIONS,FLUID_SETTINGS_READY,FLUID_SETTINGS_REGISTERED,FLUID_SETTINGS_UPDATED,FLUID_SETTINGS_VALUE,FLUID_SETTINGS_VALUE_UPDATED,GET_MAX_TICKET,HANGUP,HELP,INFO,INVALID,LEAK,LIST_TICKETS,LOCK,LOCK_ACTIVATED,LOCK_ENTERED,LOCK_ENTERING,LOCK_EXITING,LOCK_FAILED,LOCK_LEADERS,LOCK_STARTED,LOCK_STATUS,LOCK_TICKETS,LOG_ROTATE,MAX_TICKET,QUITTING,READY,RESTART,SERVICE_UNAVAILABLE,STATUS,STOP,TICKET_ADDED,TICKET_READY,UNKNOWN,UNLOCK"
	})
return()

// Function: verify SERVICE_STATUS
label(name: func_verify_service_status)
verify_message(
	command: SERVICE_STATUS,
	required_parameters: {
		service: 'fluid_settings'
	})
return()

// Function: verify a FLUID_SETTINGS_LISTEN
label(name: func_verify_fluid_settings_listen)
verify_message(
	command: FLUID_SETTINGS_LISTEN,
	required_parameters: {
		cache: "no;reply",
		names: "cluckd::server-name"
	})
return()

// Function: verify a NO_LOCK
label(name: func_verify_no_lock)
verify_message(
	command: NO_LOCK,
	server: ${hostname},
	service: website,
	required_parameters: {
		cache: "no"
	})
return()

// Function: verify a CLUSTER_STATUS
label(name: func_verify_cluster_status)
verify_message(
	command: CLUSTER_STATUS,
	service: communicatord)
return()

// Function: verify a LOCK_LEADERS
label(name: func_verify_lock_leaders)
verify_message(
	command: LOCK_LEADERS,
	service: "*",
	required_parameters: {
		election_date: `^[0-9]+(\\.[0-9]+)?$`,
		leader0: `^14\\|[0-9]+\\|127.0.0.1\\|[0-9]+\\|${hostname}$`
	},
	forbidden_parameters: {
		leader1,
		leader2
	})
return()

// Function: verify a LOCK_STARTED
label(name: func_verify_lock_started)
verify_message(
	command: LOCK_STARTED,
	service: "*",
	required_parameters: {
		election_date: `^[0-9]+(\\.[0-9]+)?$`,
		leader0: `^14\\|[0-9]+\\|127.0.0.1\\|[0-9]+\\|${hostname}$`,
		lock_id: `^14\\|[0-9]+\\|127.0.0.1\\|[0-9]+\\|${hostname}$`,
		server_name: ${hostname},
		start_time: `^[0-9]+(\\.[0-9]+)?$`
	},
	forbidden_parameters: {
		leader1,
		leader2
	})
return()

// Function: verify a LOCK READY
label(name: func_verify_lock_ready)
verify_message(
	command: LOCK_READY,
	sent_service: cluckd,
	service: ".",
	required_parameters: {
		cache: no
	})
return()

// Function: verify a LOCK FAILED
label(name: func_verify_lock_failed)
compare(expression: ${lock_failed} <=> "timedout/lock1")
if(not_equal: not_timedout_lock1_lock_failed)
verify_message(
	command: LOCK_FAILED,
	server: ${hostname},
	service: "website",
	required_parameters: {
		error: "timedout",
		key: "${hostname}/123",
		object_name: "lock1"
	})
return()
label(name: not_timedout_lock1_lock_failed)
exit(error_message: "unhandled LOCK_FAILED")

// Function: verify a UNLOCKED
label(name: func_verify_unlocked)
verify_message(
	command: UNLOCKED,
	server: ${hostname},
	service: "website",
	required_parameters: {
		error: "timedout",
		object_name: "lock1",
		tag: 505
	})
return()

// Function: verify a UNLOCKING
label(name: func_verify_unlocking)
verify_message(
	command: UNLOCKING,
	server: ${hostname},
	service: "website",
	required_parameters: {
		error: "timedout",
		object_name: "lock1",
		tag: 505
	})
return()

// Function: send HELP
label(name: func_send_help)
send_message(
	command: HELP
	)
return()

// Function: send READY
label(name: func_send_ready)
send_message(
	command: READY,
	parameters: {
		my_address: "127.0.0.1"
	})
return()

// Function: send STATUS
label(name: func_send_status)
now(variable_name: now)
send_message(
	command: STATUS,
	parameters: {
		service: "cluckd",
		cache: no,
		server: "this_server",
		status: "up",
		up_since: ${now}
	})
return()

// Function: send UNLOCK too soon
//
// This function gets called too soon so the cluckd system generates an
// error and never replies--unfortunately, at the moment I do not check
// the logs so the test itself does not verify that the error occurs...
//
label(name: func_send_unlock)
send_message(
	command: UNLOCK,
	parameters: {
		object_name: "too_soon",
		tag: 11104,
		pid: 431
	})
return()

// Function: send UNLOCK with invalid pid
label(name: func_send_unlock_with_bad_pid)
send_message(
	command: UNLOCK,
	parameters: {
		object_name: "bad_pid",
		tag: 11104,
		pid: -431
	})
return()

// Function: send UNLOCK with invalid server name
label(name: func_send_unlock_with_bad_server_name)
send_message(
	command: UNLOCK,
	sent_server: another_server, // not the correct name (on purpose)
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		object_name: "lock1",
		tag: 11104,
		pid: 435
	})
return()

// Function: send UNLOCK with invalid object name
label(name: func_send_unlock_with_bad_object_name)
send_message(
	command: UNLOCK,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		object_name: "unknown_lock",
		tag: 11104,
		pid: 435
	})
return()

// Function: send STATUS/fluid_settings
label(name: func_send_status_of_fluid_settings)
now(variable_name: now)
send_message(
	command: STATUS,
	parameters: {
		service: "fluid_settings",
		cache: no,
		server: ${hostname},
		status: "up",
		up_since: ${now}
	})
return()

// Function: send FLUID_SETTINGS_REGISTERED
label(name: func_send_fluid_settings_registered)
send_message(
	command: FLUID_SETTINGS_REGISTERED,
	server: ${hostname},
	service: cluckd)
return()

// Function: send FLUID_SETTINGS_VALUE_UPDATED
label(name: func_send_fluid_settings_value_updated)
send_message(
	command: FLUID_SETTINGS_VALUE_UPDATED,
	server: ${hostname},
	service: cluckd,
	parameters: {
		name: "cluckd::server-name",
		value: "this_very_server",
		message: "current value"
	})
return()

// Function: send FLUID_SETTINGS_READY
label(name: func_send_fluid_settings_ready)
send_message(
	command: FLUID_SETTINGS_READY,
	server: ${hostname},
	service: cluckd,
	parameters: {
		errcnt: 31
	})
return()

// Function: send LOCK_STATUS
label(name: func_send_lock_status)
send_message(
	command: LOCK_STATUS,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd)
return()

// Function: send INFO
// Parameters: ${info_mode} -- "info" or "debug"
label(name: func_send_info)
send_message(
	command: INFO,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		mode: ${info_mode}
	})
return()

// Function: send CLUSTER_UP
label(name: func_send_cluster_up)
send_message(
	command: CLUSTER_UP,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		neighbors_count: 1
	})
return()

// Function: send CLUSTER_COMPLETE
label(name: func_send_cluster_complete)
send_message(
	command: CLUSTER_COMPLETE,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		neighbors_count: 1
	})
return()

// Function: send LOCK
// Parameters: ${timeout} -- when the LOCK request times out
label(name: func_send_lock)
send_message(
	command: LOCK,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd,
	parameters: {
		object_name: "lock1",
		tag: 505,
		pid: 123,
		duration: 10,
		timeout: ${timeout}
	})
return()

// Function: send QUITTING
label(name: func_send_quitting)
send_message(
	command: QUITTING,
	sent_server: ${hostname},
	sent_service: website,
	server: ${hostname},
	service: cluckd)
return()

